---
title: "Results Reliability Generalization and Variance Decomposition"
author: "Lukas Beinhauer"
format: docx
editor: visual
---

```{r}
library(tidyverse)
```

```{r}

paths_rel <- list.files(file.path("Data/Reliability Estimates"), full.names = TRUE)

paths_alpha <- paths_rel[grep("_Alpha.csv$", paths_rel)]

alpha_estimates.list <- lapply(paths_alpha, FUN = function(x){read.csv(x)})

paths_B.alpha <- paths_rel[grep("_Bonett-Alpha.csv$", paths_rel)]

Bonett.Alpha.list <- lapply(paths_B.alpha, FUN = function(x){read.csv(x)})


# Alpha_rma.list <- readRDS(file.path("Data/Shiny Data/Alpha_rma.list.RData"))
# Bonett.Alpha_rma.list <- readRDS(file.path("Data/Shiny Data/Bonett.Alpha_rma.list.RData"))

# varT_est.list <- readRDS(file.path("Data/Variance Estimates/bootstrapped_varT.RData"))
varE_est.list <- readRDS(file.path("Data/Variance Estimates/bootstrapped_varE.RData"))
# varX_est.list <- readRDS(file.path("Notes/bootstrapped_varX.RData"))

# varT_rma.list <- readRDS(file.path("Data/Variance Estimates/bootstrapped_varT_rma.RData"))
varE_rma.list <- readRDS(file.path("Data/Variance Estimates/bootstrapped_varE_rma.RData"))
# varX_rma.list <- readRDS(file.path("Notes/bootstrapped_varX_rma.RData"))


data.list <- lapply(list.files(file.path("Data/Extracted (Project) Data"), 
                               full.names = TRUE), FUN = read.csv) 


varX_rma.list <- lapply(data.list, FUN = function(x){
  
  varX.L <- lapply(unique(x$source), FUN = function(lab){
    
    d <- x[x$source == lab, -ncol(x)]
    
    v_X <- var(rowMeans(d), na.rm = T)
    
    SE_v_X <- sqrt(2/(nrow(d) - 1))
    
    return(list(v_X = v_X,
                SE_v_X = SE_v_X))
  })
  
  varX.df <- data.frame(v_X = sapply(varX.L, FUN = function(y){y$v_X}),
                        SE_v_X = sapply(varX.L, FUN = function(y){y$SE_v_X}))
  
  metafor::rma(measure = "GEN", method = "REML",
               data = varX.df,
               yi = log(v_X), sei = SE_v_X)
  
})


backtr_rma_varX <- lapply(varX_rma.list, FUN = function(x){
  
  mu <-  exp(x$b[1] + .5*x$tau2)
  tau2 <- (mu^2) * (exp(x$tau2) - 1)
  
  return(list(mu_X = mu,
              tau2_X = tau2))
  
})

backtr_rma_varX.df <- data.frame(mu_X = sapply(backtr_rma_varX, FUN = function(x){x$mu_X}),
                                 tau2_X = sapply(backtr_rma_varX, FUN = function(x){x$tau2_X}))

backtr_rma_varX.df$tau_X <- sqrt(backtr_rma_varX.df$tau2_X)




backtr_rma_varE <- lapply(varE_rma.list, FUN = function(x){
  
  mu <-  exp(x$b[1] + .5*x$tau2)
  tau2 <- (mu^2) * (exp(x$tau2) - 1)
  
  return(list(mu_E = mu,
              tau2_E = tau2))
  
})

backtr_rma_varE.df <- data.frame(mu_E = sapply(backtr_rma_varE, FUN = function(x){x$mu_E}),
                                 tau2_E = sapply(backtr_rma_varE, FUN = function(x){x$tau2_E}))

backtr_rma_varE.df$tau_E <- sqrt(backtr_rma_varE.df$tau2_E)



```

```{r}

s_Caciop_Alpha <- summary(alpha_estimates.list[[1]]$Reliability)

r.dec <- 3

s_Caciop_Alpha_rma <- Alpha_rma.list[[1]]
s_Caciop_B.Alpha_rma <- Bonett.Alpha_rma.list[[1]]

s_Caciop_varT <- summary(varT_est.list[[1]]$var.est)
s_Caciop_varE <- summary(varE_est.list[[1]]$var.est)

s_Caciop_varT_rma <- varT_rma.list[[1]]
s_Caciop_varE_rma <- varE_rma.list[[1]]





s_ShnabelRPP_Alpha <- summary(alpha_estimates.list[[9]]$Reliability)

s_ShnabelRPP_Alpha_rma <- Alpha_rma.list[[9]]
s_ShnabelRPP_B.Alpha_rma <- Bonett.Alpha_rma.list[[9]]

s_ShnabelRPP_varT <- summary(varT_est.list[[9]]$var.est)
s_ShnabelRPP_varE <- summary(varE_est.list[[9]]$var.est)

s_ShnabelRPP_varT_rma <- varT_rma.list[[9]]
s_ShnabelRPP_varE_rma <- varE_rma.list[[9]]




s_ShnabelRev_Alpha <- summary(alpha_estimates.list[[8]]$Reliability)

s_ShnabelRev_Alpha_rma <- Alpha_rma.list[[8]]
s_ShnabelRev_B.Alpha_rma <- Bonett.Alpha_rma.list[[8]]

s_ShnabelRev_varT <- summary(varT_est.list[[8]]$var.est)
s_ShnabelRev_varE <- summary(varE_est.list[[8]]$var.est)

s_ShnabelRev_varT_rma <- varT_rma.list[[8]]
s_ShnabelRev_varE_rma <- varE_rma.list[[8]]





s_HexHH_Alpha <- summary(alpha_estimates.list[[6]]$Reliability)

s_HexHH_Alpha_rma <- Alpha_rma.list[[6]]
s_HexHH_B.Alpha_rma <- Bonett.Alpha_rma.list[[6]]

s_HexHH_varT <- summary(varT_est.list[[6]]$var.est)
s_HexHH_varE <- summary(varE_est.list[[6]]$var.est)

s_HexHH_varT_rma <- varT_rma.list[[6]]
s_HexHH_varE_rma <- varE_rma.list[[6]]




s_HexEM_Alpha <- summary(alpha_estimates.list[[4]]$Reliability)

s_HexEM_Alpha_rma <- Alpha_rma.list[[4]]
s_HexEM_B.Alpha_rma <- Bonett.Alpha_rma.list[[4]]

s_HexEM_varT <- summary(varT_est.list[[4]]$var.est)
s_HexEM_varE <- summary(varE_est.list[[4]]$var.est)

s_HexEM_varT_rma <- varT_rma.list[[4]]
s_HexEM_varE_rma <- varE_rma.list[[4]]





s_HexEX_Alpha <- summary(alpha_estimates.list[[5]]$Reliability)

s_HexEX_Alpha_rma <- Alpha_rma.list[[5]]
s_HexEX_B.Alpha_rma <- Bonett.Alpha_rma.list[[5]]

s_HexEX_varT <- summary(varT_est.list[[5]]$var.est)
s_HexEX_varE <- summary(varE_est.list[[5]]$var.est)

s_HexEX_varT_rma <- varT_rma.list[[5]]
s_HexEX_varE_rma <- varE_rma.list[[5]]





s_HexAG_Alpha <- summary(alpha_estimates.list[[2]]$Reliability)

s_HexAG_Alpha_rma <- Alpha_rma.list[[2]]
s_HexAG_B.Alpha_rma <- Bonett.Alpha_rma.list[[2]]

s_HexAG_varT <- summary(varT_est.list[[2]]$var.est)
s_HexAG_varE <- summary(varE_est.list[[2]]$var.est)

s_HexAG_varT_rma <- varT_rma.list[[2]]
s_HexAG_varE_rma <- varE_rma.list[[2]]





s_HexCO_Alpha <- summary(alpha_estimates.list[[3]]$Reliability)

s_HexCO_Alpha_rma <- Alpha_rma.list[[3]]
s_HexCO_B.Alpha_rma <- Bonett.Alpha_rma.list[[3]]

s_HexCO_varT <- summary(varT_est.list[[3]]$var.est)
s_HexCO_varE <- summary(varE_est.list[[3]]$var.est)

s_HexCO_varT_rma <- varT_rma.list[[3]]
s_HexCO_varE_rma <- varE_rma.list[[3]]





s_HexOX_Alpha <- summary(alpha_estimates.list[[7]]$Reliability)

s_HexOX_Alpha_rma <- Alpha_rma.list[[7]]
s_HexOX_B.Alpha_rma <- Bonett.Alpha_rma.list[[7]]

s_HexOX_varT <- summary(varT_est.list[[7]]$var.est)
s_HexOX_varE <- summary(varE_est.list[[7]]$var.est)

s_HexOX_varT_rma <- varT_rma.list[[7]]
s_HexOX_varE_rma <- varE_rma.list[[7]]



varT_alt.L <- lapply(1:length(varE_rma.list), FUN = function(x){
  
  varT_tau2 <- backtr_rma_varX.df$tau2_X[x] - varE_rma.list[[x]]$tau2
  muT <- backtr_rma_varX.df$mu_X[x] - varE_rma.list[[x]]$b[1]
  
  return(list(varT_tau2 = varT_tau2,
              varT_tau = sqrt(varT_tau2),
              muT = muT))
  
})

varT_alt.df <- data.frame(varT_tau2 = sapply(varT_alt.L, FUN = function(x){x$varT_tau2}),
                          varT_tau = sapply(varT_alt.L, FUN = function(x){x$varT_tau}),
                          muT = sapply(varT_alt.L, FUN = function(x){x$muT}))

names(varE_rma.list)[9] <- "Mazar_HEXACO_OX"

varE.df <- data.frame(varE_tau2 = sapply(varE_rma.list, FUN = function(x){x$tau2}),
                      varE_tau = sqrt(sapply(varE_rma.list, FUN = function(x){x$tau2})),
                      muE = sapply(varE_rma.list, FUN = function(x){x$b[1]}))


s_Caciop_B.Alpha_Botella_rma <- metafor::rma(yi = s_Caciop_B.Alpha_rma$yi,
                                             vi = s_Caciop_B.Alpha_rma$vi,
                                             measure = "GEN",
                                             method = "REML",
                                             mods = ~ varX_rma.list[[1]]$yi)

mu_s_Caciop_B.Alpha_Botella_rma_backtr <-  exp(s_Caciop_B.Alpha_Botella_rma$b[1] + .5*s_Caciop_B.Alpha_Botella_rma$tau2)

tau_s_Caciop_B.Alpha_Botella_rma_backtr <- (mu_s_Caciop_B.Alpha_Botella_rma_backtr^2) * (exp(s_Caciop_B.Alpha_Botella_rma$tau2) - 1)




s_ShnabelRPP_B.Alpha_Botella_rma <- metafor::rma(yi = s_ShnabelRPP_B.Alpha_rma$yi,
                                             vi = s_ShnabelRPP_B.Alpha_rma$vi,
                                             measure = "GEN",
                                             method = "REML",
                                             mods = ~ varX_rma.list[[9]]$yi)

mu_s_ShnabelRPP_B.Alpha_Botella_rma_backtr <-  exp(s_ShnabelRPP_B.Alpha_Botella_rma$b[1] + .5*s_ShnabelRPP_B.Alpha_Botella_rma$tau2)

tau_s_ShnabelRPP_B.Alpha_Botella_rma_backtr <- (mu_s_ShnabelRPP_B.Alpha_Botella_rma_backtr^2) * (exp(s_ShnabelRPP_B.Alpha_Botella_rma$tau2) - 1)







s_HexHH_B.Alpha_Botella_rma <- metafor::rma(yi = s_HexHH_B.Alpha_rma$yi,
                                             vi = s_HexHH_B.Alpha_rma$vi,
                                             measure = "GEN",
                                             method = "REML",
                                             mods = ~ varX_rma.list[[6]]$yi)

mu_s_HexHH_B.Alpha_Botella_rma_backtr <-  exp(s_HexHH_B.Alpha_Botella_rma$b[1] + .5*s_HexHH_B.Alpha_Botella_rma$tau2)

tau_s_HexHH_B.Alpha_Botella_rma_backtr <- (mu_s_HexHH_B.Alpha_Botella_rma_backtr^2) * (exp(s_HexHH_B.Alpha_Botella_rma$tau2) - 1)


```

```{r}
library(tidyverse)

CV_ratio.df <- data.frame(varT_alt.df,
                          varE.df) %>% 
  mutate(CV_E = varE_tau / muE,
         CV_T = varT_tau / muT) %>% 
  mutate(ratio_ET = CV_E / CV_T,
         ratio_TE = CV_T / CV_E) 

CV_ratio.df$project <- as.factor(row.names(CV_ratio.df))

ggplot(CV_ratio.df) +
  geom_point(aes(x = CV_E, y = project)) +
  labs(y = "Project / MASC", x = expression(CV[E] == frac(tau[E], mu[E])))

ggplot(CV_ratio.df) +
  geom_point(aes(x = CV_T, y = project)) +
  labs(y = "Project / MASC", x = expression(CV["T"] == frac(tau["T"], mu["T"])))

ggplot(CV_ratio.df) +
  geom_point(aes(x = ratio_ET, y = project)) +
  labs(y = "Project / MASC", x = expression(R[CV["E"],CV["T"]] == frac(frac(tau[E], mu[E]), frac(tau["T"], mu["T"]))))

ggplot(CV_ratio.df) +
  geom_point(aes(x = ratio_TE, y = project))+
  labs(y = "Project / MASC", x = expression(CV[E] == frac(tau[E], mu[E]))) +
  labs(y = "Project / MASC", x = expression(R[CV["T"],CV["E"]] == frac(frac(tau["T"], mu["T"]), frac(tau[E], mu[E]))))


```

```{r}
packages <- c("dplyr", "here", "magrittr", "ggplot2")

# check, whether library already installed or not - install and load as needed:
apply(as.matrix(packages), MARGIN = 1, FUN = function(x) {
  
  pkg_avail <- nzchar(system.file(package = x))   # check if library is installed on system
  
  if(pkg_avail){
    require(x, character.only = TRUE)             # load the library, if already installed
    
  }else{
    install.packages(x)                           # install the library, if missing
    require(x, character.only = TRUE)             # load after installation
  }
})
```

```{r}


df_comparison <- read.csv(here("Simulation Data/Sim80000_rma_df.csv"))

df_comparison_means <- df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(across(everything(), \(x) mean(x, na.rm = T)))

names(df_comparison_means) <- c("CVT", "CVE", "rel", 
                                paste0("mean_", names(df_comparison_means)[!names(df_comparison_means) %in% c("CVT", "CVE", "rel")]))


df_comparison_80ll <- df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(across(everything(), \(x) quantile(x, probs = .1, na.rm = T)))

names(df_comparison_80ll) <- c("CVT", "CVE", "rel", 
                                paste0("ll80_", names(df_comparison_80ll)[!names(df_comparison_80ll) %in% c("CVT", "CVE", "rel")]))


df_comparison_80ul <- df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(across(everything(), \(x) quantile(x, probs = .9, na.rm = T)))

names(df_comparison_80ul) <- c("CVT", "CVE", "rel", 
                                paste0("ul80_", names(df_comparison_80ul)[!names(df_comparison_80ul) %in% c("CVT", "CVE", "rel")]))


df_comparison_vars <- df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(across(tau_T:mu_rel_Botella_transf, \(x) var(x, na.rm = T)))

names(df_comparison_vars) <- c("CVT", "CVE", "rel", 
                               paste0("var_", names(df_comparison_vars)[!names(df_comparison_vars) %in% c("CVT", "CVE", "rel")]))


df_comparison_summary <- data.frame(df_comparison_means,
                                    df_comparison_80ll[,!names(df_comparison_80ll) %in% c("CVT", "CVE", "rel")],
                                    df_comparison_80ul[,!names(df_comparison_80ul) %in% c("CVT", "CVE", "rel")],
                                    df_comparison_vars[,!names(df_comparison_vars) %in% c("CVT", "CVE", "rel")])


```

Firstly, most obviously, figure 1 shows that there is a strong overestimation of heterogeneity in score reliability, if no heterogeneity is present in either of the variance components. This effect is stronger at lower levels of score reliability. This finding is not surprising. Estimation of heterogeneity of any parameters tends to be biased positively, if heterogeneity is not present or low (reference). As negative variances are undesirable, these tend to be set to zero in most estimation software. Thereby, as sampling errors produce estimates of heterogeneity surrounding the true value of zero, the selection for positive values leads to a positive bias in estimates of heterogeneity. More importantly, figure 1 shows that for low levels of score reliability, paired with low levels of heterogeneity in the error score variance component, heterogeneity in score reliability tends to be slightly underestimated. If heterogeneity in true score variance is present as well, it tends to alleviate this bias, however, as higher levels of heterogeneity in true score variance appear to increase the bias in heterogeneity of score reliability estimates. Lastly, high levels of targeted score reliability paired with high levels of heterogeneity in true score variances leads to some overestimation of heterogeneity in score reliability. While some biases could be noted, it appears that overall, estimation of heterogeneity in score reliability is generally precise, depending somewhat on the level of heterogeneity and score reliability observed. The mean absolute bias in heterogeneity in relative terms is at most about `r round(max(df_comparison_summary$mean_bias_tau_rel[-c(1:5)]/df_comparison_summary$mean_tau_rel_transf[-c(1:5)]), 3)` of size of the actual heterogeneity in score reliability, on average, this ratio is about `r round(mean(df_comparison_summary$mean_bias_tau_rel[-c(1:5)]/df_comparison_summary$mean_tau_rel_transf[-c(1:5)]), 3)`.

```{r}
ggplot(data = df_comparison_summary) +
  geom_ribbon(aes(x = mean_pred.tau_rel,
                  ymin = ul80_bias_tau_rel,
                  ymax = ll80_bias_tau_rel),
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_pred.tau_rel, y = mean_bias_tau_rel, colour = as.factor(rel))) +
  facet_grid(rows = vars(CVE),
             cols = vars(CVT)) +
  labs(y = "mean bias in estimated heterogeneity (tau) in score reliability",
       x = "predicted heterogeneity (tau) in score reliability",
       title = "Heterogeneity in Score Reliability",
       subtitle = "rows = CVE, columns = CVT", 
       colour = "Score \n Reliability")

df_comparison_summary %>% 
  filter(CVT == 0) %>% 
  ggplot() +
  geom_ribbon(aes(x = mean_pred.tau_rel,
                  ymin = ul80_bias_tau_rel,
                  ymax = ll80_bias_tau_rel),
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_pred.tau_rel, y = mean_bias_tau_rel, colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "mean bias in estimated heterogeneity\n (tau) in score reliability",
       x = "predicted heterogeneity (tau) in score reliability",
       title = "Heterogeneity in Score Reliability",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")

df_comparison_summary %>% 
  filter(CVT == .3) %>% 
  ggplot() +
  geom_ribbon(aes(x = mean_pred.tau_rel,
                  ymin = ul80_bias_tau_rel,
                  ymax = ll80_bias_tau_rel),
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_pred.tau_rel, y = mean_bias_tau_rel, colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "mean bias in estimated heterogeneity\n (tau) in score reliability",
       x = "predicted heterogeneity (tau) in score reliability",
       title = "Heterogeneity in Score Reliability",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")
```

Figure 2 pertains to the efficiency of heterogeneity in score reliability estimates. Overall, the standard deviation of estimates within a single condition reveal a straightforward picture. Most obviously, we see that efficency of estimation in heterogeneity, in terms of standard deviation, is a function of level of score reliability. High levels of score reliability lead to higher level of efficiency, as the estimates' standard deviations are lower, while lower levels of score reliability come with lower levels of efficiency. Such findings are to be expected. As higher levels of score reliability carry smaller and more stable standard errors, estimation of heterogeneity should be less uncertain as well. Additionally we observe that efficiency of score reliability heterogeneity estimation seems to increase with higher levels of heterogeneity in either true or score variance component.

The ratio of standard deviation to true heterogeneity is at most `r round(max(sqrt(df_comparison_summary$var_tau_rel_transf[!df_comparison_summary$CVE == 0 & !df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_rel[!df_comparison_summary$CVE == 0 & !df_comparison_summary$CVT == 0]), 3)`, on average `r round(mean(sqrt(df_comparison_summary$var_tau_rel_transf[!df_comparison_summary$CVE == 0 & !df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_rel[!df_comparison_summary$CVE == 0 & !df_comparison_summary$CVT == 0]), 3)`, if there is any heterogeneity present.

```{r}
ggplot(data = df_comparison_summary) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_pred.tau_rel, y = sqrt(var_tau_rel_transf), colour = as.factor(rel))) +
  facet_grid(rows = vars(CVE),
             cols = vars(CVT)) +
  labs(y = "mean variance in estimated heterogeneity (tau) in score reliability",
       x = "predicted heterogeneity (tau) in score reliability",
       title = "Heterogeneity in Score Reliability",
       subtitle = "rows = CVE, columns = CVT", 
       colour = "Score \n Reliability")
```

In figure 3, the positive bias in heterogeneity estimates of error score variance is most obvious in cases where actually no heterogeneity is present. Similarly to the case of heterogeneity in score reliability, this can easily be explained by the positive bias of selection for positive estimates of heterogeneity. However, it also becomes apparent that this bias decreases with higher levels of score reliability. While this may seem informative, this bias is a simple function of the size of mean error score variance. As score reliability increases, the absolute size of error score variance decreases. Thereby, as the scale of the estimated parameter decreases, so does the bias of its estimated heterogeneity.

More interestingly, if there is heterogeneity present in the error score variance, the ratio of mean absolute bias to simulated score reliability heterogeneity is at most `r round(max(abs(df_comparison_summary$mean_bias_tau_varE[!df_comparison_summary$CVE == 0])/df_comparison_summary$mean_tau_varE[!df_comparison_summary$CVE == 0]), 3)`. On average this ratio is `r round(mean(abs(df_comparison_summary$mean_bias_tau_varE[!df_comparison_summary$CVE == 0])/df_comparison_summary$mean_tau_varE[!df_comparison_summary$CVE == 0]), 3)`. From figure 2 no particularly obvious function of bias in error score variance estimates becomes apparent, concerning the parameters of induced heterogeneity or level of score reliability. However, in general it seems that the estimation of heterogeneity in error score variance, in terms of bias, is unaffected by the level of heterogeneity in true score variance.

```{r}
ggplot(data = df_comparison_summary) +
  geom_abline(intercept = 0, slope = 0) +
  geom_ribbon(aes(x = mean_tau_varE,
                  ymin = ul80_bias_tau_varE,
                  ymax = ll80_bias_tau_varE),
              fill = "blue", alpha = .1) +
  geom_point(aes(x = mean_tau_varE, y = mean_bias_tau_varE, colour = as.factor(CVE))) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel)) +
  labs(y = "mean bias in heterogeneity (tau) in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       subtitle = "rows = CVT, columns = rel",
       colour = "CVE") +
  theme(legend.position = "bottom")

df_comparison_summary %>% 
  filter(CVT == 0) %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 0) +
  geom_ribbon(aes(x = mean_tau_varE,
                  ymin = ul80_bias_tau_varE,
                  ymax = ll80_bias_tau_varE),
              fill = "blue", alpha = .1) +
  geom_point(aes(x = mean_tau_varE, y = mean_bias_tau_varE, colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "mean bias in heterogeneity (tau)\n in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")

df_comparison_summary %>% 
  filter(CVT == .3) %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 0) +
  geom_ribbon(aes(x = mean_tau_varE,
                  ymin = ul80_bias_tau_varE,
                  ymax = ll80_bias_tau_varE),
              fill = "blue", alpha = .1) +
  geom_point(aes(x = mean_tau_varE, y = mean_bias_tau_varE, colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "mean bias in heterogeneity (tau)\n in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")



df_comparison_summary %>% 
  filter(CVT == 0) %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_tau_varE, y = sqrt(var_tau_E), colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "efficiency in heterogeneity (tau)\n in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")

df_comparison_summary %>% 
  filter(CVT == .3) %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_tau_varE, y = sqrt(var_tau_E), colour = as.factor(rel))) +
  facet_wrap(vars(CVE), nrow = 1) +
  labs(y = "efficiency in heterogeneity (tau)\n in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       colour = "Score\n Reliability") +
  theme(legend.position = "bottom")
 
library(ggExtra)

df_comparison %>% 
  filter(CVT == 0) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .01) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  facet_wrap(vars(CVE), nrow = 1, scales = "free") +
  theme(legend.position = "bottom")


df_comparison %>% 
  filter(CVT == 0 & CVE == 0) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .1) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  # facet_wrap(vars(CVE), nrow = 1, scales = "free") +
  theme(legend.position = "bottom")

df_comparison %>% 
  filter(CVT == 0 & CVE == .1) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .01) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  # facet_wrap(vars(CVE), nrow = 1, scales = "free") +
  theme(legend.position = "bottom")

df_comparison %>% 
  filter(CVT == 0 & CVE == .2) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .01) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  # facet_wrap(vars(CVE), nrow = 1, scales = "free") +
  theme(legend.position = "bottom")

df_comparison %>% 
  filter(CVT == 0 & CVE == .3) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .01) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  # facet_wrap(vars(CVE), nrow = 1, scales = "free") +
  theme(legend.position = "bottom")


df_comparison %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 1) +
  geom_density(aes(y = tau_E, colour = as.factor(rel))) +
  facet_wrap(vars(CVE))

```

```{r}

library(ggpubr)

p1 <- df_comparison %>% 
  filter(CVT == 0) %>% 
  ggplot(aes(y = tau_E, x = tau_varE, colour = as.factor(rel))) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(position = position_jitter(width = .03), 
             alpha = .01) +
  # geom_density(aes(y = tau_E, x = tau_varE, colour = "red")) +
  # geom_segment(data = df_comparison_summary, aes(x = mean_tau_varE, xend = mean_tau_varE,
  #                                                y = mean_tau_E - sqrt(var_tau_E),
  #                                                yend = mean_tau_E + sqrt(var_tau_E)),
  #              colour = "black") +
  # geom_point(data = df_comparison_summary, aes(y = mean_tau_E, x = mean_tau_varE)
  #            , colour = "white") +
  facet_wrap(vars(factor(CVE, labels = c("CV[EV] == 0", "CV[EV] == .1", "CV[EV] == .2", "CV[EV] == .3"))), 
             nrow = 4, scales = "fixed", labeller = label_parsed) +
  labs(y = expression(hat(tau)[EV]),
       x = expression(tau[EV]),
       subtitle = "a) Estimates",
       colour = "Score\nReliability") +
  theme(legend.position = "none", 
        panel.background = element_rect(fill = "transparent"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"))

p2 <- df_comparison_summary %>% 
  filter(CVT == 0) %>% 
  ggplot() +
  geom_abline(intercept = 0, slope = 0) +
  geom_ribbon(aes(x = mean_tau_varE,
                  ymin = ul80_bias_tau_varE,
                  ymax = ll80_bias_tau_varE),
              fill = "blue", alpha = .1) +
  geom_point(aes(x = mean_tau_varE, y = mean_bias_tau_varE, colour = as.factor(rel))) +
  facet_wrap(vars(factor(CVE, labels = c("CV[EV] == 0", "CV[EV] == .1", "CV[EV] == .2", "CV[EV] == .3"))), 
             nrow = 4, scales = "fixed", labeller = label_parsed) +
  labs(y = expression("mean bias in " ~ hat(tau)[EV]),
       x = expression(tau[EV]),
       subtitle = "b) Bias",
       colour = "Score\nReliability") +
  theme(legend.position = "bottom", 
        panel.background = element_rect(fill = "transparent"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"))

p3 <- df_comparison_summary %>% 
  filter(CVT == 0) %>% 
  ggplot() +
  geom_point(aes(x = mean_tau_varE, y = sqrt(var_tau_E), colour = as.factor(rel))) +
  scale_y_reverse() +
  facet_wrap(vars(factor(CVE, labels = c("CV[EV] == 0", "CV[EV] == .1", "CV[EV] == .2", "CV[EV] == .3"))), 
             nrow = 4, scales = "fixed", labeller = label_parsed) +
  labs(y = expression("efficiency in " ~ hat(tau)[EV]),
       x = expression(tau[EV]),
       subtitle = "c) Efficiency",
       colour = "Score\nReliability") +
  theme(legend.position = "bottom", 
        panel.background = element_rect(fill = "transparent"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill = "transparent"))

pleg <- ggpubr::get_legend(p3)

parr <- ggpubr::ggarrange(p1, p2, p3, ncol = 3, common.legend = TRUE, legend = "bottom", 
                          legend.grob = pleg)

annotate_figure(parr, top = text_grob("Estimation quality in explicitly modelling EV"))

ggsave(file = "C:/Users/Lukas/Downloads/figure1.png",
       plot = last_plot(), 
       width = 10, 
       height = 8)

```

In figure 4, it becomes apparent that efficiency in estimation of heterogeneity in error score variances is, similarly to its bias, a function of level of score reliability. Again, as score reliability increases, error score variance decreases. The smaller scale of this parameter thereby leads to less absolute variation. Also, similarly to the bias in heterogeneity of error score variance, the efficiency of its estimation remains unaffected by the level of heterogeneity in the true score variance component.

If there is heterogeneity present in error score variance, figure 4 demonstrates that efficiency in the estimation of this parameter, in terms of its standard deviation, increases almost linearly with heterogeneity induced. Interestingly, we see that, if no heterogeneity is present at all, efficiency in estimation is about the same size (very slightly smaller, but we shouldn't overinterpret this) as if little heterogeneity is present. Whenever there is true heterogeneity present, the ratio of standard deviation to simulated error score variance heterogeneity is at most `r round(max(sqrt(df_comparison_summary$var_tau_E[!df_comparison_summary$CVE == 0])/df_comparison_summary$mean_tau_varE[!df_comparison_summary$CVE == 0]), 3)`, on average `r round(mean(sqrt(df_comparison_summary$var_tau_E[!df_comparison_summary$CVE == 0])/df_comparison_summary$mean_tau_varE[!df_comparison_summary$CVE == 0]), 3)`.

```{r}
ggplot(data = df_comparison_summary) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_tau_varE, y = sqrt(var_tau_E), colour = as.factor(CVE))) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel)) +
  labs(y = "sd in heterogeneity (tau) in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       subtitle = "rows = CVT, columns = rel",
       colour = "CVE")
```

Concerning the estimation of heterogeneity in true score variance, figure 5 seems to imply a similar relationship between its bias and the parameters of heterogeneity in score variance components or level of score reliability. However, most importantly it has to be noted that everything occurs on a different, much larger scale. If there is heterogeneity present, the largest ratio of absolute mean bias and simulated true score variance heterogeneity is `r round(max(abs(df_comparison_summary$mean_bias_tau_varT[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)`. On average, this ratio is `r round(mean(abs(df_comparison_summary$mean_bias_tau_varT[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)`, the median is `r round(median(abs(df_comparison_summary$mean_bias_tau_varT[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)` - several magnitudes larger than for estimation of heterogeneity in error score variances.

Concerning the function of mean bias in heterogeneity of true score variance estimates, based on levels of score reliability or heterogeneity in the error score variance components, no obvious relationship is revealed in figure 5. Estimation appears unaffected by induction of heterogeneity in error score variance. More surprisingly, it appears that even levels of score reliability and different levels of true heterogeneity in true score variances have no immediately obvious impact on the bias in these estimates. Most crucially, we note that while a large bias remains, if no heterogeneity is present, a generally negative, but by magnitudes smaller, bias is noted if there is true heterogeneity present.

```{r}
ggplot(data = df_comparison_summary) +
  geom_ribbon(aes(x = mean_tau_varT, 
                  ymin = ul80_bias_tau_varT_alt,
                  ymax = ll80_bias_tau_varT_alt),
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_tau_varT, y = mean_bias_tau_varT_alt, colour = as.factor(CVT))) + 
  facet_grid(rows = vars(CVE),
             cols = vars(rel)) +
  labs(y = "mean bias in estimated heterogeneity (tau) in true score variance",
       x = "predicted heterogeneity (tau) in true score variance",
       title = "Heterogeneity in True Score Variance",
       subtitle = "rows = CVE, columns = rel, var(T) = var(X) - var(E)",
       colour = "CVT") 
```

Concerning the efficiency of true score variance heterogeneity estimation figure 6 reveals that, compared to efficiency in estimation of error score variance heterogeneity, again performs magnitudes worse. If there is heteroeneity present, the ratio of standard deviation to simulated heterogeneity is at most `r round(max(sqrt(df_comparison_summary$var_tau_T[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)`, on average `r round(mean(sqrt(df_comparison_summary$var_tau_T[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)`, the median is `r round(median(sqrt(df_comparison_summary$var_tau_T[!df_comparison_summary$CVT == 0])/df_comparison_summary$mean_tau_varT[!df_comparison_summary$CVT == 0]), 3)`.

It seems that heterogeneity in error score variance does affect the efficiency of the true score variance heterogeneity estimator. At higher levels of heterogeneity in error score variances, efficiency in estimation of true score variance is lower (standard deviations are larger). Since heterogeneity in true score variances is estimated using a prior estimate of error score variance, such a function was to be expected. Efficiency in error score variance estimation decreases, as the error score variance heterogeneity increases - therefore, efficiency of subsequent estimates is expected to suffer in the same way.

Also, it can generally be observed that higher levels of score reliability improve efficiency. At higher levels of score reliability, the absolute true score variance is larger. Such a larger scale might have implied that the standard deviation of parameter estimates in a single condition grows. However, it appears that the improved efficiency in estimation, due to higher levels of score reliability, surpasses even this. Additionally, in figure 6 the relationship between varying levels of heterogeneity in true score variances and the efficiency of their estimation is not obvious. It appears that, if there is actual heterogeneity present, at lower levels of score reliability, higher levels of heterogeneity come with improved efficiency. However, at higher levels of score reliability, starting at .7, heterogeneity in true score variance produces the lowest standard deviation in estimates at CV_T = .2. Both at lower and higher levels of heterogeneity, efficiency is lower (standard deviations are larger).

```{r}
ggplot(data = df_comparison_summary) +
  geom_abline(intercept = 0, slope = 0) +
  geom_point(aes(x = mean_tau_varT, y = sqrt(var_tau_T_alt), colour = as.factor(CVT))) + 
  facet_grid(rows = vars(CVE),
             cols = vars(rel)) +
  labs(y = "sd in estimated heterogeneity (tau) in true score variance",
       x = "predicted heterogeneity (tau) in true score variance",
       title = "Heterogeneity in True Score Variance",
       subtitle = "rows = CVE, columns = rel, var(T) = var(X) - var(E)",
       colour = "CVT")  
```

## Comparison Current & Botella & Suero correction

Botella & Suero suggested to add (log-transformed) observed score variances as a predictor to a meta-regression model of (Bonnett-transformed) score reliability estimates. They claim that this essentially equals a model/test for error score variances. We may have analytical arguments on why estimates generated from such a model can not be expected to actually represent heterogeneity in error score variances, but whether these arguments actually have implications in practice remains to be shown. Therefore, as a first step, estimates of heterogeneity stemming from both modelling approaches will be compared.

Figures 7, 8 and 9 aim to show in how far estimates of heterogeneity generated from either of the two models relate to the true heterogeneity induced in the simulation. Since the meta-regression model produces estimates on the log-scale, figure 8 is included. This figure demonstrates that on the log-scale the meta-regression model underestimates heterogeneity in log-transformed error score variance. Most remarkably, the model produces mostly estimates of zero heterogeneity, if little heterogeneity of CV_E = .1 was truly present in the data. As larger degrees of heterogeneity is induced in the simulation, the model does produce non-zero estimate, which are still visibly underestimated. Higher levels of score reliability seem to reduce this bias at higher levels of error score variance heterogeneity, but does not alleviate it.

```{r}
ggplot(data = df_comparison_summary) +
  geom_ribbon(aes(x = mean_tau_varE, 
                  ymin = ul80_tau_E,
                  ymax = ll80_tau_E), 
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(aes(x = mean_tau_varE, y = mean_tau_E, colour = as.factor(CVE))) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel)) +
  labs(y = "mean estimated heterogeneity (tau) in error score variance",
       x = "predicted heterogeneity (tau) in error score variance",
       title = "Heterogeneity in Error Score Variance",
       subtitle = "rows = CVT, columns = rel",
       colour = "CVE")

ggplot(data = df_comparison_summary) +
  geom_ribbon(aes(x = mean_tau_lnvarE, 
                  ymin = ul80_tau_Bonett_rel_Botella,
                  ymax = ul80_tau_Bonett_rel_Botella), 
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(aes(x = mean_tau_lnvarE, y = mean_tau_Bonett_rel_Botella, 
                 colour = as.factor(CVE))) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel)) +
  labs(y = "mean estimated heterogeneity (tau) in Bonnett - Botella-cor.",
       x = "predicted heterogeneity (tau) in ln error score variance",
       title = "Heterogeneity in Score Reliability - Botella correction",
       subtitle = "rows = CVE, columns = CVT") 

ggplot(data = df_comparison_summary) +
  geom_ribbon(aes(x = mean_tau_varE, 
                  ymin = ll80_tau_Bonett_rel_Botella_transf,
                  ymax = ul80_tau_Bonett_rel_Botella_transf), 
              fill = "blue", alpha = .1) +
  geom_abline(intercept = 0, slope = 1) +
  geom_point(aes(x = mean_tau_varE, y = mean_tau_Bonett_rel_Botella_transf)) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel),
             scales = "free") +
  labs(y = "mean estimated heterogeneity (tau) in Bonnett - Botella-cor.",
       x = "predicted heterogeneity (tau) in ln error score variance",
       title = "Heterogeneity in Score Reliability - Botella correction",
       subtitle = "rows = CVE, columns = CVT") 
```

In figure 9, back-transformed estimates are presented on the original scale of the error score variances. It appears that the negative bias on the log-scale produces severely distorted estimates of error score variance heterogeneity. While this may seem damning, one needs to take into account that this method was not developed to produce estimates of error score variance heterogeneity. Instead it was intended to simply detect whether statistically significant variation in (latent) error score variances are present. Therefore, we additionally assessed in how far the meta-regression model does indicate that statistically significant variation in the error score variances could be identified, in conditions where true heterogeneity in those was present:

```{r}
df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(Botella_sig = mean(p_Bonett_rel_Botella < .05, na.rm = T),
            varE_sig = mean(p_E < .05, na.rm = T),
            Bonnett_sig = mean(p_Bonett < .05, na.rm = T)) %>% 
  ggplot() +
  geom_point(aes(x = CVE-.008, y = Botella_sig), colour = "blue") +
  geom_line(aes(x = CVE-.008, y = Botella_sig), colour = "blue", linetype = "dashed") +
  geom_point(aes(x = CVE, y = Bonnett_sig), colour = "green") +
  geom_line(aes(x = CVE, y = Bonnett_sig), colour = "green", linetype = "dashed") +
  geom_point(aes(x = CVE+.008, y = varE_sig), colour = "red") +
  geom_line(aes(x = CVE+.008, y = varE_sig), colour = "red", linetype = "dashed") +
  geom_abline(intercept = .05, slope = 0) +
  facet_grid(rows = vars(CVT),
             cols = vars(rel)) +
  labs(x = expression("CV"["E"]),
       y = "Rate of statistical significance")



df_c_s_rate <- df_comparison %>% 
  group_by(CVT, CVE, rel) %>% 
  summarise(Botella_sig = mean(p_Bonett_rel_Botella < .05, na.rm = T),
            varE_sig = mean(p_E < .05, na.rm = T),
            Bonnett_sig = mean(p_Bonett < .05, na.rm = T))


df_rate_vis <- data.frame(sig = c(df_c_s_rate$Botella_sig,
                                  df_c_s_rate$varE_sig,
                                  df_c_s_rate$Bonnett_sig),
                          method = as.factor(c(rep("Bot", length(df_c_s_rate$Botella_sig)),
                                               rep("VE", length(df_c_s_rate$Botella_sig)),
                                               rep("Bon", length(df_c_s_rate$Botella_sig)))),
                          CVT = df_c_s_rate$CVT,
                          CVE = df_c_s_rate$CVE,
                          rel = df_c_s_rate$rel) 




p4 <- df_rate_vis %>% 
  filter(CVE == 0, rel == .5) %>% 
  ggplot() +
  geom_bar(aes(x = method, y = sig, fill = method), stat = "identity", colour = "black") +
  geom_text(aes(x = method, y = sig, label = paste0(round(sig*100, 0), "%")), vjust = -.1) +
  scale_x_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  scale_fill_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  scale_y_continuous(labels = paste0(c(0, .25, .5, .75, 1) * 100, "%"), limits = c(0, 1.02)) +
  facet_wrap(vars(factor(CVT, labels = c("CV[TV] == 0", "CV[TV] == .1", "CV[TV] == .2", "CV[TV] == .3"))), 
             nrow = 1, scales = "fixed", labeller = label_parsed) +
  theme(legend.position = "bottom", 
        panel.background = element_rect(fill = "#EAEAEA"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill = "transparent"),
        axis.line = element_line(colour = "black"))  +
  labs(x = "Method", y = "Type-I-Error",
       subtitle = "a) Score Reliability of .5")

p5 <- df_rate_vis %>% 
  filter(CVE == 0, rel == .9) %>% 
  ggplot() +
  geom_bar(aes(x = method, y = sig, fill = method), stat = "identity", colour = "black") +
  geom_text(aes(x = method, y = sig, label = paste0(round(sig*100, 0), "%")), vjust = -.1) +
  scale_y_continuous(labels = paste0(c(0, .25, .5, .75, 1) * 100, "%"), limits = c(0, 1.02)) +
  scale_x_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  scale_fill_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  facet_wrap(vars(factor(CVT, labels = c("CV[TV] == 0", "CV[TV] == .1", "CV[TV] == .2", "CV[TV] == .3"))), 
             nrow = 1, scales = "fixed", labeller = label_parsed) +
  theme(legend.position = "bottom", 
        panel.background = element_rect(fill = "#EAEAEA"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill = "transparent"),
        axis.line = element_line(colour = "black")) +
  labs(x = "Method", y = "Type-I-Error",
       subtitle = "b) Score Reliability of .9")

pleg2 <- ggpubr::get_legend(p4)

parr2 <- ggpubr::ggarrange(p4, p5, ncol = 1, legend = "none")

annotate_figure(parr2, top = text_grob("Type-I-Error comparison across methods"))

ggsave(file = "C:/Users/Lukas/Downloads/figure2.png",
       plot = last_plot(), 
       width = 10, 
       height = 7)

p6 <- df_rate_vis %>% 
  filter(CVE != 0, rel == .5) %>% 
  ggplot() +
  geom_bar(aes(x = method, y = sig, fill = method), stat = "identity", colour = "black") +
  geom_text(aes(x = method, y = sig, label = paste0(round(sig*100, 0), "%")), vjust = -.1) +
  scale_y_continuous(labels = paste0(c(0, .25, .5, .75, 1) * 100, "%"), limits = c(0, 1.02)) +
  scale_x_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  scale_fill_discrete(labels = c("RG-MA", "B&S", "EV-MA")) +
  facet_grid(rows = vars(factor(CVE, labels = c("CV[EV] == .1", "CV[EV] == .2", "CV[EV] == .3"))),
             cols = vars(factor(CVT, labels = c("CV[TV] == 0", "CV[TV] == .1", "CV[TV] == .2", "CV[TV] == .3"))),
             labeller = label_parsed) +
  theme(legend.position = "none", 
        panel.background = element_rect(fill = "#EAEAEA"), 
        plot.background = element_rect(fill = "transparent", colour = "transparent"), 
        panel.grid.major = element_line(colour = "grey"),
        panel.grid.minor = element_line(colour = "transparent"),
        axis.ticks = element_line(colour = "grey"),
        strip.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill = "transparent"),
        axis.line = element_line(colour = "black")) +
  labs(x = "Method", y = "Power")

annotate_figure(p6, top = "Power comparison across methods")

ggsave(file = "C:/Users/Lukas/Downloads/figure3.png",
       plot = last_plot(), 
       width = 10, 
       height = 7)

```

Figure 10 demonstrates the rates of detection of statistically significant variation in error score variances, using the XXX hypothesis test. It appears that using Botella & Suero's meta-regression model, in cases of zero heterogeneity, the hypothesis test reliably flags none of the data-sets as containing error score variance heterogeneity. The hypothesis test concerning the heterogeneity in error score variance estimates model explicitly flags about .09 of all cases as statistically significant, which did not contain any heterogeneity, well above the expected rate of .05 type-I-error rate (an alpha of .05 was used to test for statistically significant heterogeneity).

As some heterogeneity is induced in the simulation, in the form of CV_E of .1, the meta-regression model still flags none of the cases as containing statistically significant heterogeneity in error score variances. The model on the decomposed variance estimates on the other hand identifies statistically significant heterogeneity in error score variance 100% of the time. As more heterogeneity is introduced, the meta-regression model identifies variation in the error score variances more often. At higher levels of score reliability, more to all cases are flagged as statistically significant. Additionally, higher levels of heterogeneity in true score variance also lead to higher rates of error score variance heterogeneity detection, implying that the model does not only pick up heterogeneity in the error score variances but also in the true score variances.

Such behaviour fits our expectation, due to the analytical arguments stated above, pertaining equations X and X. Adding (log-transformed) observed score variance as a predictor can not explain all variation observed in the difference of (log-transformed) error and observed score variance. As observed and error score variance are not independent, this additional covariance between the factor, which is also defined as the heterogeneity in true score variance, can not be explained. Thereby, larger levels of heterogeneity in true score variance lead to higher levels of remaining heterogeneity. This can be observed most strongly at a low level of score reliability .5 and heterogeneity in error score variance of CVE = .2. As heterogeneity in CVT grows from 0 to .3, the significance rate grows, even though variations in error score variances should remain constant.

Similarly, figure 10 demonstrates how a hypothesis test for statistically significant heterogeneity in transformed score reliability does not pertain exclusively to differences in error score variance across samples. If no heterogeneity is present in this score variance component, we do see how the test flags statistically significant heterogeneity in score reliability as the heterogeneity in true score variance is induced and grows. This result was to be expected, as heterogeneity in both score variance components necessarily lead to heterogeneity in score reliability, demonstrated in equations X, X and X.

### Cacioppo

Data set 1 concerned the scale of Need for Cognition (Cacioppo & Petty, 1982), consisting of 6 Likert-stye items (5-point scale). Measured across 21 labs in Ebersole et al. (2016), using Cronbach's Alpha, score reliability varied between `r round(s_Caciop_Alpha[1], r.dec)` and `r round(s_Caciop_Alpha[6], r.dec)`, with a mean value of `r round(s_Caciop_Alpha[4], r.dec)` and median value `r round(s_Caciop_Alpha[3], r.dec)`. Table 1 contains estimates and results from the application of three different meta-analytic attempts to assess differences in measuring quality of Need for Cognition in these 21 labs. It appears that the typical reliability generalization study does identify statistically significant heterogeneity in (transformed) score reliability estimates. Adding (log-transformed) observed score variance as a predictor in a meta-regression model, according to Botella & Suero (2012), leads to no concrete evidence concerning heterogeneity. The statistical test of heterogeneity in estimates of error score variance also does not identify statistically significant heterogeneity.

| Method                 | Estimate of $\tau_{\sigma^2_E}$                                 | CVE                                                                                                    | QE                                                | p-value                                                                                                              | conclusion                                                                                                                                |     |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| RGA                    | -/-                                                             | -/-                                                                                                    | `r round(s_Caciop_B.Alpha_rma$QE, r.dec)`         | `r ifelse(s_Caciop_B.Alpha_rma$QEp < .001, yes = .001, no = round(s_Caciop_B.Alpha_rma$QEp, r.dec))`                 | `r ifelse(s_Caciop_B.Alpha_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")`         |     |
| RGA-Botella corr.      | `r round(sqrt(tau_s_Caciop_B.Alpha_Botella_rma_backtr), r.dec)` | `r round(sqrt(tau_s_Caciop_B.Alpha_Botella_rma_backtr)/mu_s_Caciop_B.Alpha_Botella_rma_backtr, r.dec)` | `r round(s_Caciop_B.Alpha_Botella_rma$QE, r.dec)` | `r ifelse(s_Caciop_B.Alpha_Botella_rma$QEp < .001, yes = .001, no = round(s_Caciop_B.Alpha_Botella_rma$QEp, r.dec))` | `r ifelse(s_Caciop_B.Alpha_Botella_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |     |
| Variance decomposition | `r round(sqrt(backtr_rma_varE.df$tau_E[1]), r.dec)`             | `r round(sqrt(backtr_rma_varE.df$tau_E[1])/backtr_rma_varE.df$mu_E[1], r.dec)`                         | `r round(varE_rma.list[[1]]$QE, r.dec)`           | `r ifelse(varE_rma.list[[1]]$QEp < .001, yes = .001, no = round(varE_rma.list[[1]]$QEp, r.dec))`                     | `r ifelse(varE_rma.list[[1]]$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")`           |     |

Additionally, using the meta-analytic estimates of the decomposed score variance components, we can compute the ratio of true and error score variance coefficients of variation $\frac{CV_E}{CV_T}$. Concerning the Need for Cognition replications, we find a ratio of `r round((sqrt(backtr_rma_varE.df$tau_E[1])/backtr_rma_varE.df$mu_E[1])/(sqrt(backtr_rma_varX.df$tau_X[1] - backtr_rma_varE.df$tau_E[1])/(backtr_rma_varX.df$mu_X[1] - backtr_rma_varE.df$mu_E[1])), r.dec)`. Such a ratio implies, that the heterogeneity in error score variance, scaled to the coefficient of variation, is about a third of the heterogeneity in true score variance. While such a ratio may not serve as evidence alone, it might help disentangle in how far either of the true score variance components varies across samples, and thereby is responsible for differences in score reliability.

Data set 2 concerned the scale of Sense of Power (Shnabel & Nadler, 2008), consisting of 3 Likert-stye items (7-point scale). Measured across 8 labs in Baranski et al. (2020), using Cronbach's Alpha, specifically for those labs following the RPP-protocol, score reliability varied between `r round(s_ShnabelRPP_Alpha[1], r.dec)` and `r round(s_ShnabelRPP_Alpha[6], r.dec)`, with a mean value of `r round(s_ShnabelRPP_Alpha[4], r.dec)` and median value `r round(s_ShnabelRPP_Alpha[3], r.dec)`. Table 2 describes estimates and results from the application of the three different methods again, concerning differences in measuring quality of Sense of Power in these 8 replications. Again, the classical reliability generalization does identify statistically significant heterogeneity, while adding (log-transformed) observed score variance as a predictor leads to no statistically significant results. However, a meta-analysis of estimates of error score variance does imply that statistically significant differences exist in error score variance across samples.

| Method                 | Estimate of $\tau_{\sigma^2_E}$                                     | CVE                                                                                                            | QE                                                    | p-value                                                                                                                      |                                                                                                                                    conclusion |
|------------|------------|------------|------------|------------|-----------:|
| RGA                    | -/-                                                                 | -/-                                                                                                            | `r round(s_ShnabelRPP_B.Alpha_rma$QE, r.dec)`         | `r ifelse(s_ShnabelRPP_B.Alpha_rma$QEp < .001, yes = .001, no = round(s_ShnabelRPP_B.Alpha_rma$QEp, r.dec))`                 |         `r ifelse(s_ShnabelRPP_B.Alpha_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |
| RGA-Botella corr.      | `r round(sqrt(tau_s_ShnabelRPP_B.Alpha_Botella_rma_backtr), r.dec)` | `r round(sqrt(tau_s_ShnabelRPP_B.Alpha_Botella_rma_backtr)/mu_s_ShnabelRPP_B.Alpha_Botella_rma_backtr, r.dec)` | `r round(s_ShnabelRPP_B.Alpha_Botella_rma$QE, r.dec)` | `r ifelse(s_ShnabelRPP_B.Alpha_Botella_rma$QEp < .001, yes = .001, no = round(s_ShnabelRPP_B.Alpha_Botella_rma$QEp, r.dec))` | `r ifelse(s_ShnabelRPP_B.Alpha_Botella_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |
| Variance decomposition | `r round(sqrt(backtr_rma_varE.df$tau_E[9]), r.dec)`                 | `r round(sqrt(backtr_rma_varE.df$tau_E[9])/backtr_rma_varE.df$mu_E[9], r.dec)`                                 | `r round(varE_rma.list[[9]]$QE, r.dec)`               | `r ifelse(varE_rma.list[[9]]$QEp < .001, yes = .001, no = round(varE_rma.list[[9]]$QEp, r.dec))`                             |               `r ifelse(varE_rma.list[[9]]$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |

Only data stemming from replications where the RPP-protocol was used was assessed. However, analysis of replications making use of the revised protocol led to the same conclusions as those described in table 2, see appendix X. Additionally, assessing the ratio of variation coefficient in variance components, we find a ratio of `r round((sqrt(backtr_rma_varE.df$tau_E[9])/backtr_rma_varE.df$mu_E[9])/(sqrt(backtr_rma_varX.df$tau_X[9] - backtr_rma_varE.df$tau_E[9])/(backtr_rma_varX.df$mu_X[9] - backtr_rma_varE.df$mu_E[9])), r.dec)`. Concerning the measuring instrument of Need for Power, we find that scaled heterogeneity in the error score variance component is about 1.5 times of the true score variance heterogeneity.

Data set 3 concerned HEXACO-60 self-report personality inventory (Ashton & Lee, 2009), assessed as a filler-instrument in the replication of Mazar et al. (2008) by Verschuere et al. (2018). Here, specifically the honesty-humility scale was assessed. This scale consisting of 10 Likert-stye items (5-point scale). Measured across 19 labs, using Cronbach's Alpha, score reliability varied between `r round(s_HexHH_Alpha[1], r.dec)` and `r round(s_HexHH_Alpha[6], r.dec)`, with a mean value of `r round(s_HexHH_Alpha[4], r.dec)` and median value `r round(s_HexHH_Alpha[3], r.dec)`. Results concerning the last empirical example can be found in table 3. Again, reliability generalization does identify heterogeneity in score reliability while adding observed score variance as a predictor removes the estimate of statistically significant heterogeneity. Directly assessing the error score variance estimates using a random-effects meta-analysis does identify statistically significant heterogeneity.

| Method                 | Estimate of $\tau_{\sigma^2_E}$                                | CVE                                                                                                  | QE                                               | p-value                                                                                                            |                                                                                                                               conclusion |
|------------|------------|------------|------------|------------|-----------:|
| RGA                    | -/-                                                            | -/-                                                                                                  | `r round(s_HexHH_B.Alpha_rma$QE, r.dec)`         | `r ifelse(s_HexHH_B.Alpha_rma$QEp < .001, yes = .001, no = round(s_HexHH_B.Alpha_rma$QEp, r.dec))`                 |         `r ifelse(s_HexHH_B.Alpha_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |
| RGA-Botella corr.      | `r round(sqrt(tau_s_HexHH_B.Alpha_Botella_rma_backtr), r.dec)` | `r round(sqrt(tau_s_HexHH_B.Alpha_Botella_rma_backtr)/mu_s_HexHH_B.Alpha_Botella_rma_backtr, r.dec)` | `r round(s_HexHH_B.Alpha_Botella_rma$QE, r.dec)` | `r ifelse(s_HexHH_B.Alpha_Botella_rma$QEp < .001, yes = .001, no = round(s_HexHH_B.Alpha_Botella_rma$QEp, r.dec))` | `r ifelse(s_HexHH_B.Alpha_Botella_rma$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |
| Variance decomposition | `r round(sqrt(backtr_rma_varE.df$tau_E[6]), r.dec)`            | `r round(sqrt(backtr_rma_varE.df$tau_E[6])/backtr_rma_varE.df$mu_E[6], r.dec)`                       | `r round(varE_rma.list[[6]]$QE, r.dec)`          | `r ifelse(varE_rma.list[[6]]$QEp < .001, yes = .001, no = round(varE_rma.list[[6]]$QEp, r.dec))`                   |          `r ifelse(varE_rma.list[[6]]$QEp < .05, yes = "Differences in measuring quality", no = "no concrete evidence for differences")` |

While the honesty-humility scale was selected for a demonstration here, any HEXACO-60 dimension would have led to the same conclusions as those described in table 3. Concerning Honesty-Humility, we also find a ratio of coefficients of variation of `r round((sqrt(backtr_rma_varE.df$tau_E[6])/backtr_rma_varE.df$mu_E[6])/(sqrt(backtr_rma_varX.df$tau_X[6] - backtr_rma_varE.df$tau_E[6])/(backtr_rma_varX.df$mu_X[6] - backtr_rma_varE.df$mu_E[6])), r.dec)`. It would appear that heterogeneity in true and error score variance components, scaled to the coefficients of variation, are about the same size.

# Old Results

## Results Reliability Generalization and Variance Decomposition

### Cacioppo

Data set 1 concerned the scale of Need for Cognition (Cacioppo & Petty, 1982), consisting of 6 Likert-stye items (5-point scale). Measured across 21 labs in Ebersole et al. (2016), using Cronbach's Alpha, score reliability varied between `r round(s_Caciop_Alpha[1], r.dec)` and `r round(s_Caciop_Alpha[6], r.dec)`, with a mean value of `r round(s_Caciop_Alpha[4], r.dec)` and median value `r round(s_Caciop_Alpha[3], r.dec)`. Performing a random-effects meta-analysis on the untransformed Cronbach's Alpha estimates, we find a meta-analytic mean estimate of `r round(s_Caciop_Alpha_rma$b[1], r.dec)` (`r round(s_Caciop_Alpha_rma$ci.lb, r.dec)` : `r round(s_Caciop_Alpha_rma$ci.ub, r.dec)`). Additionally, we find a significant degree of heterogeneity in score reliability, at Q(`r s_Caciop_Alpha_rma$k - 1`) = `r round(s_Caciop_Alpha_rma$QE, r.dec)`, p `r ifelse(s_Caciop_Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_Caciop_Alpha_rma$QEp, r.dec)))`. In terms of I\^2, heterogeneity is `r round(s_Caciop_Alpha_rma$I2, r.dec)`%, which, according to XXX constitutes a large level of heterogeneity. In terms of tau, we find a standard deviation of `r round(sqrt(s_Caciop_Alpha_rma$tau2), r.dec)` in true values of Cronbach's Alpha. Similarly, when assessing Bonett-transformed Cronbach's Alpha estimates, we find a meta-analytic mean of `r round(s_Caciop_B.Alpha_rma$b[1], r.dec)`. Back-transformed this constitutes a Cronbach's Alpha of `r round(1-exp(s_Caciop_B.Alpha_rma$b[1]), r.dec)` (CI: `r round(1-exp(s_Caciop_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_Caciop_B.Alpha_rma$ci.lb), r.dec)`) (difference in MA-est. emerges at the 3rd decimal). Heterogeneity in Bonett-transformed estimates of Cronbach's Alpha is also of statistically significant degree: Q(`r s_Caciop_Alpha_rma$k - 1`) = `r round(s_Caciop_B.Alpha_rma$QE, r.dec)`, p `r ifelse(s_Caciop_B.Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_Caciop_B.Alpha_rma$QEp, r.dec)))`. Standardized heterogeneity estimates of I\^2 = `r round(s_Caciop_B.Alpha_rma$I2, r.dec)`% and H\^2 = `r round(s_Caciop_B.Alpha_rma$H2, r.dec)` display highly similar amounts of heterogeneity. When using McDonald's Omega to estimate score reliability, the results change only to a very small degree. Therefore, estimates using McDonald's Omega can be found in the supplemental materials.

Also, we use Cronbach's Alpha to decompose the observed variance into its true and error score variance components:

| {}     | True Score Variance                |               Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Min    | `r round(s_Caciop_varT[1], r.dec)` | `r round(s_Caciop_varE[1], r.dec)` |
| Q1     | `r round(s_Caciop_varT[2], r.dec)` | `r round(s_Caciop_varE[2], r.dec)` |
| Median | `r round(s_Caciop_varT[3], r.dec)` | `r round(s_Caciop_varE[3], r.dec)` |
| Q3     | `r round(s_Caciop_varT[5], r.dec)` | `r round(s_Caciop_varE[5], r.dec)` |
| Max    | `r round(s_Caciop_varT[6], r.dec)` | `r round(s_Caciop_varE[6], r.dec)` |
| Mean   | `r round(s_Caciop_varT[4], r.dec)` | `r round(s_Caciop_varE[4], r.dec)` |

Performing a random-effects meta-analysis on the components directly leads to:

| {}                             | True Score Variance                                                                    |                                                                   Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Meta-Analytic Mean Estimate    | `r round(s_Caciop_varT_rma$b[1], r.dec)`                                               |                                               `r round(s_Caciop_varE_rma$b[1], r.dec)` |
| Confidence Interval            | `r round(s_Caciop_varT_rma$ci.lb, r.dec)` : `r round(s_Caciop_varT_rma$ci.ub, r.dec)`  |  `r round(s_Caciop_varE_rma$ci.lb, r.dec)` : `r round(s_Caciop_varE_rma$ci.ub, r.dec)` |
| Heterogeneity tau              | `r round(sqrt(s_Caciop_varT_rma$tau2), r.dec)`                                         |                                         `r round(sqrt(s_Caciop_varE_rma$tau2), r.dec)` |
| Heterogeneity I\^2             | `r round(s_Caciop_varT_rma$I2, r.dec)`                                                 |                                                 `r round(s_Caciop_varE_rma$I2, r.dec)` |
| Heterogeneity H\^2             | `r round(s_Caciop_varT_rma$H2, r.dec)`                                                 |                                                 `r round(s_Caciop_varE_rma$H2, r.dec)` |
| Q(`r s_Caciop_varT_rma$k - 1`) | `r round(s_Caciop_varT_rma$QE, r.dec)`                                                 |                                                 `r round(s_Caciop_varE_rma$QE, r.dec)` |
| p-value QE                     | `r ifelse(s_Caciop_varT_rma$QEp < .001, "<.001", round(s_Caciop_varT_rma$QEp, r.dec))` | `r ifelse(s_Caciop_varE_rma$QEp < .001, "<.001", round(s_Caciop_varE_rma$QEp, r.dec))` |

Inspecting table 1, for the true score variance, we identify a statistically significant amount of heterogeneity. For the error score variance on the other hand, we could not distinguish heterogeneity in the error score variance from zero.

### Shnabel Sense of Power (RPP)

Data set 2 concerned the scale of Sense of Power (Shnabel & Nadler, 2008), consisting of 3 Likert-stye items (7-point scale). Measured across 8 labs in Baranski et al. (2020), using Cronbach's Alpha, specifically for those labs following the RPP-protocol, score reliability varied between `r round(s_ShnabelRPP_Alpha[1], r.dec)` and `r round(s_ShnabelRPP_Alpha[6], r.dec)`, with a mean value of `r round(s_ShnabelRPP_Alpha[4], r.dec)` and median value `r round(s_ShnabelRPP_Alpha[3], r.dec)`. Performing a random-effects meta-analysis on the untransformed Cronbach's Alpha estimates, we find a meta-analytic mean estimate of `r round(s_ShnabelRPP_Alpha_rma$b[1], r.dec)` (`r round(s_ShnabelRPP_Alpha_rma$ci.lb, r.dec)` : `r round(s_ShnabelRPP_Alpha_rma$ci.ub, r.dec)`). Additionally, we find a significant degree of heterogeneity in score reliability, at Q(`r s_ShnabelRPP_Alpha_rma$k - 1`) = `r round(s_ShnabelRPP_Alpha_rma$QE, r.dec)`, p `r ifelse(s_ShnabelRPP_Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_ShnabelRPP_Alpha_rma$QEp, r.dec)))`. In terms of I\^2, heterogeneity is `r round(s_ShnabelRPP_Alpha_rma$I2, r.dec)`%, which, according to XXX constitutes a medium level of heterogeneity. In terms of tau, we find a standard deviation of `r round(sqrt(s_ShnabelRPP_Alpha_rma$tau2), r.dec)` in true values of Cronbach's Alpha. Similarly, when assessing Bonett-transformed Cronbach's Alpha estimates, we find a meta-analytic mean of `r round(s_ShnabelRPP_B.Alpha_rma$b[1], r.dec)`. Back-transformed this constitutes a Cronbach's Alpha of `r round(1-exp(s_ShnabelRPP_B.Alpha_rma$b[1]), r.dec)` (CI: `r round(1-exp(s_ShnabelRPP_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_ShnabelRPP_B.Alpha_rma$ci.lb), r.dec)`) (difference in MA-est. emerges at the 3rd decimal). Heterogeneity in Bonett-transformed estimates of Cronbach's Alpha is also of statistically significant degree: Q(`r s_ShnabelRPP_Alpha_rma$k - 1`) = `r round(s_ShnabelRPP_B.Alpha_rma$QE, r.dec)`, p `r ifelse(s_ShnabelRPP_B.Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_ShnabelRPP_B.Alpha_rma$QEp, r.dec)))`. Standardized heterogeneity estimates of I\^2 = `r round(s_ShnabelRPP_B.Alpha_rma$I2, r.dec)`% and H\^2 = `r round(s_ShnabelRPP_B.Alpha_rma$H2, r.dec)` display highly similar amounts of heterogeneity.

Also, we use Cronbach's Alpha to decompose the observed variance into its true and error score variance components:

| {}     | True Score Variance                    |                   Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Min    | `r round(s_ShnabelRPP_varT[1], r.dec)` | `r round(s_ShnabelRPP_varE[1], r.dec)` |
| Q1     | `r round(s_ShnabelRPP_varT[2], r.dec)` | `r round(s_ShnabelRPP_varE[2], r.dec)` |
| Median | `r round(s_ShnabelRPP_varT[3], r.dec)` | `r round(s_ShnabelRPP_varE[3], r.dec)` |
| Q3     | `r round(s_ShnabelRPP_varT[5], r.dec)` | `r round(s_ShnabelRPP_varE[5], r.dec)` |
| Max    | `r round(s_ShnabelRPP_varT[6], r.dec)` | `r round(s_ShnabelRPP_varE[6], r.dec)` |
| Mean   | `r round(s_ShnabelRPP_varT[4], r.dec)` | `r round(s_ShnabelRPP_varE[4], r.dec)` |

Performing a random-effects meta-analysis on the components directly leads to:

| {}                                 | True Score Variance                                                                            |                                                                           Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Meta-Analytic Mean Estimate        | `r round(s_ShnabelRPP_varT_rma$b[1], r.dec)`                                                   |                                                   `r round(s_ShnabelRPP_varE_rma$b[1], r.dec)` |
| Confidence Interval                | `r round(s_ShnabelRPP_varT_rma$ci.lb, r.dec)` : `r round(s_ShnabelRPP_varT_rma$ci.ub, r.dec)`  |  `r round(s_ShnabelRPP_varE_rma$ci.lb, r.dec)` : `r round(s_ShnabelRPP_varE_rma$ci.ub, r.dec)` |
| Heterogeneity tau                  | `r round(sqrt(s_ShnabelRPP_varT_rma$tau2), r.dec)`                                             |                                             `r round(sqrt(s_ShnabelRPP_varE_rma$tau2), r.dec)` |
| Heterogeneity I\^2                 | `r round(s_ShnabelRPP_varT_rma$I2, r.dec)`                                                     |                                                     `r round(s_ShnabelRPP_varE_rma$I2, r.dec)` |
| Heterogeneity H\^2                 | `r round(s_ShnabelRPP_varT_rma$H2, r.dec)`                                                     |                                                     `r round(s_ShnabelRPP_varE_rma$H2, r.dec)` |
| Q(`r s_ShnabelRPP_varT_rma$k - 1`) | `r round(s_ShnabelRPP_varT_rma$QE, r.dec)`                                                     |                                                     `r round(s_ShnabelRPP_varE_rma$QE, r.dec)` |
| p-value QE                         | `r ifelse(s_ShnabelRPP_varT_rma$QEp < .001, "<.001", round(s_ShnabelRPP_varT_rma$QEp, r.dec))` | `r ifelse(s_ShnabelRPP_varE_rma$QEp < .001, "<.001", round(s_ShnabelRPP_varE_rma$QEp, r.dec))` |

In table 2 we find that, heterogeneity in true score variance could not be statistically distinguished from zero. On the other hand, for the error score variance, we do find statistically significant heterogeneity.

### Shnabel Sense of Power (Rev)

Comparing those results to the labs employing the revised protocol, score reliability varied between `r round(s_ShnabelRev_Alpha[1], r.dec)` and `r round(s_ShnabelRev_Alpha[6], r.dec)`, with a mean value of `r round(s_ShnabelRev_Alpha[4], r.dec)` and median value `r round(s_ShnabelRev_Alpha[3], r.dec)`. Performing a random-effects meta-analysis on the untransformed Cronbach's Alpha estimates, we find a meta-analytic mean estimate of `r round(s_ShnabelRev_Alpha_rma$b[1], r.dec)` (`r round(s_ShnabelRev_Alpha_rma$ci.lb, r.dec)` : `r round(s_ShnabelRev_Alpha_rma$ci.ub, r.dec)`). Additionally, we find no significant degree of heterogeneity in score reliability, at Q(`r s_ShnabelRev_Alpha_rma$k - 1`) = `r round(s_ShnabelRev_Alpha_rma$QE, r.dec)`, p `r ifelse(s_ShnabelRev_Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_ShnabelRev_Alpha_rma$QEp, r.dec)))`. In terms of I\^2, heterogeneity is `r round(s_ShnabelRev_Alpha_rma$I2, r.dec)`%, which, according to XXX constitutes a low to medium level of heterogeneity. In terms of tau, we find a standard deviation of `r round(sqrt(s_ShnabelRev_Alpha_rma$tau2), r.dec)` in true values of Cronbach's Alpha. Similarly, when assessing Bonett-transformed Cronbach's Alpha estimates, we find a meta-analytic mean of `r round(s_ShnabelRev_B.Alpha_rma$b[1], r.dec)`. Back-transformed this constitutes a Cronbach's Alpha of `r round(1-exp(s_ShnabelRev_B.Alpha_rma$b[1]), r.dec)` (CI: `r round(1-exp(s_ShnabelRev_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_ShnabelRev_B.Alpha_rma$ci.lb), r.dec)`) (difference in MA-est. emerges at the 3rd decimal). Heterogeneity in Bonett-transformed estimates of Cronbach's Alpha is of statistically significant degree: Q(`r s_ShnabelRev_Alpha_rma$k - 1`) = `r round(s_ShnabelRev_B.Alpha_rma$QE, r.dec)`, p `r ifelse(s_ShnabelRev_B.Alpha_rma$QEp < .001, "<.001", paste0("= ", round(s_ShnabelRev_B.Alpha_rma$QEp, r.dec)))`. Standardized heterogeneity estimates of I\^2 = `r round(s_ShnabelRev_B.Alpha_rma$I2, r.dec)`% and H\^2 = `r round(s_ShnabelRev_B.Alpha_rma$H2, r.dec)` display highly similar amounts of heterogeneity.

Also, we use Cronbach's Alpha to decompose the observed variance into its true and error score variance components:

| {}     | True Score Variance                    |                   Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Min    | `r round(s_ShnabelRev_varT[1], r.dec)` | `r round(s_ShnabelRev_varE[1], r.dec)` |
| Q1     | `r round(s_ShnabelRev_varT[2], r.dec)` | `r round(s_ShnabelRev_varE[2], r.dec)` |
| Median | `r round(s_ShnabelRev_varT[3], r.dec)` | `r round(s_ShnabelRev_varE[3], r.dec)` |
| Q3     | `r round(s_ShnabelRev_varT[5], r.dec)` | `r round(s_ShnabelRev_varE[5], r.dec)` |
| Max    | `r round(s_ShnabelRev_varT[6], r.dec)` | `r round(s_ShnabelRev_varE[6], r.dec)` |
| Mean   | `r round(s_ShnabelRev_varT[4], r.dec)` | `r round(s_ShnabelRev_varE[4], r.dec)` |

Performing a random-effects meta-analysis on the components directly leads to:

| {}                                 | True Score Variance                                                                            |                                                                           Error Score Variance |
|---------------------|---------------------|-----------------------------:|
| Meta-Analytic Mean Estimate        | `r round(s_ShnabelRev_varT_rma$b[1], r.dec)`                                                   |                                                   `r round(s_ShnabelRev_varE_rma$b[1], r.dec)` |
| Confidence Interval                | `r round(s_ShnabelRev_varT_rma$ci.lb, r.dec)` : `r round(s_ShnabelRev_varT_rma$ci.ub, r.dec)`  |  `r round(s_ShnabelRev_varE_rma$ci.lb, r.dec)` : `r round(s_ShnabelRev_varE_rma$ci.ub, r.dec)` |
| Heterogeneity tau                  | `r round(sqrt(s_ShnabelRev_varT_rma$tau2), r.dec)`                                             |                                             `r round(sqrt(s_ShnabelRev_varE_rma$tau2), r.dec)` |
| Heterogeneity I\^2                 | `r round(s_ShnabelRev_varT_rma$I2, r.dec)`                                                     |                                                     `r round(s_ShnabelRev_varE_rma$I2, r.dec)` |
| Heterogeneity H\^2                 | `r round(s_ShnabelRev_varT_rma$H2, r.dec)`                                                     |                                                     `r round(s_ShnabelRev_varE_rma$H2, r.dec)` |
| Q(`r s_ShnabelRev_varT_rma$k - 1`) | `r round(s_ShnabelRev_varT_rma$QE, r.dec)`                                                     |                                                     `r round(s_ShnabelRev_varE_rma$QE, r.dec)` |
| p-value QE                         | `r ifelse(s_ShnabelRev_varT_rma$QEp < .001, "<.001", round(s_ShnabelRev_varT_rma$QEp, r.dec))` | `r ifelse(s_ShnabelRev_varE_rma$QEp < .001, "<.001", round(s_ShnabelRev_varE_rma$QEp, r.dec))` |

In table 3 we find that, similar to the RPP-protocol, in the Revised protocol we also find statistically significant heterogeneity only in the error score variance components.

### HEXACO

#### Cronbach's Alpha

| Scale                        | HH                                                                                     | EM                                                                                     | EX                                                                                     | AG                                                                                     | CO                                                                                     |                                                                                     OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Meta-analytic mean estimate  | `r round(s_HexHH_Alpha_rma$b[1], r.dec)`                                               | `r round(s_HexEM_Alpha_rma$b[1], r.dec)`                                               | `r round(s_HexEX_Alpha_rma$b[1], r.dec)`                                               | `r round(s_HexAG_Alpha_rma$b[1], r.dec)`                                               | `r round(s_HexCO_Alpha_rma$b[1], r.dec)`                                               |                                               `r round(s_HexOX_Alpha_rma$b[1], r.dec)` |
| Confidence Interval          | `r round(s_HexHH_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexHH_Alpha_rma$ci.ub, r.dec)`  | `r round(s_HexEM_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexEM_Alpha_rma$ci.ub, r.dec)`  | `r round(s_HexEX_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexEX_Alpha_rma$ci.ub, r.dec)`  | `r round(s_HexAG_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexAG_Alpha_rma$ci.ub, r.dec)`  | `r round(s_HexCO_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexCO_Alpha_rma$ci.ub, r.dec)`  |  `r round(s_HexOX_Alpha_rma$ci.lb, r.dec)` : `r round(s_HexOX_Alpha_rma$ci.ub, r.dec)` |
| Heterogeneity tau            | `r round(sqrt(s_HexHH_Alpha_rma$tau2), r.dec)`                                         | `r round(sqrt(s_HexEM_Alpha_rma$tau2), r.dec)`                                         | `r round(sqrt(s_HexEX_Alpha_rma$tau2), r.dec)`                                         | `r round(sqrt(s_HexAG_Alpha_rma$tau2), r.dec)`                                         | `r round(sqrt(s_HexCO_Alpha_rma$tau2), r.dec)`                                         |                                         `r round(sqrt(s_HexOX_Alpha_rma$tau2), r.dec)` |
| Heteroeneity I\^2            | `r round(s_HexHH_Alpha_rma$I2, r.dec)`                                                 | `r round(s_HexEM_Alpha_rma$I2, r.dec)`                                                 | `r round(s_HexEX_Alpha_rma$I2, r.dec)`                                                 | `r round(s_HexAG_Alpha_rma$I2, r.dec)`                                                 | `r round(s_HexCO_Alpha_rma$I2, r.dec)`                                                 |                                                 `r round(s_HexOX_Alpha_rma$I2, r.dec)` |
| Heterogeneity H\^2           | `r round(s_HexHH_Alpha_rma$H2, r.dec)`                                                 | `r round(s_HexEM_Alpha_rma$H2, r.dec)`                                                 | `r round(s_HexEX_Alpha_rma$H2, r.dec)`                                                 | `r round(s_HexAG_Alpha_rma$H2, r.dec)`                                                 | `r round(s_HexCO_Alpha_rma$H2, r.dec)`                                                 |                                                 `r round(s_HexOX_Alpha_rma$H2, r.dec)` |
| Q(`r s_HexHH_Alpha_rma$k-1`) | `r round(s_HexHH_Alpha_rma$QE, r.dec)`                                                 | `r round(s_HexEM_Alpha_rma$QE, r.dec)`                                                 | `r round(s_HexEX_Alpha_rma$QE, r.dec)`                                                 | `r round(s_HexAG_Alpha_rma$QE, r.dec)`                                                 | `r round(s_HexCO_Alpha_rma$QE, r.dec)`                                                 |                                                 `r round(s_HexOX_Alpha_rma$QE, r.dec)` |
| P-value QE                   | `r ifelse(s_HexHH_Alpha_rma$QEp < .001, "<.001", round(s_HexHH_Alpha_rma$QEp, r.dec))` | `r ifelse(s_HexEM_Alpha_rma$QEp < .001, "<.001", round(s_HexEM_Alpha_rma$QEp, r.dec))` | `r ifelse(s_HexEX_Alpha_rma$QEp < .001, "<.001", round(s_HexEX_Alpha_rma$QEp, r.dec))` | `r ifelse(s_HexAG_Alpha_rma$QEp < .001, "<.001", round(s_HexAG_Alpha_rma$QEp, r.dec))` | `r ifelse(s_HexCO_Alpha_rma$QEp < .001, "<.001", round(s_HexCO_Alpha_rma$QEp, r.dec))` | `r ifelse(s_HexOX_Alpha_rma$QEp < .001, "<.001", round(s_HexOX_Alpha_rma$QEp, r.dec))` |

| Scale  | HH                                 | EM                                 | EX                                 | AG                                 | CO                                 |                                 OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Min    | `r round(s_HexHH_Alpha[1], r.dec)` | `r round(s_HexEM_Alpha[1], r.dec)` | `r round(s_HexEX_Alpha[1], r.dec)` | `r round(s_HexAG_Alpha[1], r.dec)` | `r round(s_HexCO_Alpha[1], r.dec)` | `r round(s_HexOX_Alpha[1], r.dec)` |
| Q1     | `r round(s_HexHH_Alpha[2], r.dec)` | `r round(s_HexEM_Alpha[2], r.dec)` | `r round(s_HexEX_Alpha[2], r.dec)` | `r round(s_HexAG_Alpha[2], r.dec)` | `r round(s_HexCO_Alpha[2], r.dec)` | `r round(s_HexOX_Alpha[2], r.dec)` |
| Median | `r round(s_HexHH_Alpha[3], r.dec)` | `r round(s_HexEM_Alpha[3], r.dec)` | `r round(s_HexEX_Alpha[3], r.dec)` | `r round(s_HexAG_Alpha[3], r.dec)` | `r round(s_HexCO_Alpha[3], r.dec)` | `r round(s_HexOX_Alpha[3], r.dec)` |
| Q3     | `r round(s_HexHH_Alpha[5], r.dec)` | `r round(s_HexEM_Alpha[5], r.dec)` | `r round(s_HexEX_Alpha[5], r.dec)` | `r round(s_HexAG_Alpha[5], r.dec)` | `r round(s_HexCO_Alpha[5], r.dec)` | `r round(s_HexOX_Alpha[5], r.dec)` |
| Max    | `r round(s_HexHH_Alpha[6], r.dec)` | `r round(s_HexEM_Alpha[6], r.dec)` | `r round(s_HexEX_Alpha[6], r.dec)` | `r round(s_HexAG_Alpha[6], r.dec)` | `r round(s_HexCO_Alpha[6], r.dec)` | `r round(s_HexOX_Alpha[6], r.dec)` |
| Mean   | `r round(s_HexHH_Alpha[4], r.dec)` | `r round(s_HexEM_Alpha[4], r.dec)` | `r round(s_HexEX_Alpha[4], r.dec)` | `r round(s_HexAG_Alpha[4], r.dec)` | `r round(s_HexCO_Alpha[4], r.dec)` | `r round(s_HexOX_Alpha[4], r.dec)` |

##### Back-transformed Bonett-estimates (meta-analytic results)

| Scale                          | HH                                                                                                      | EM                                                                                                      | EX                                                                                                      | AG                                                                                                      | CO                                                                                                      |                                                                                                      OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Meta-analytic mean estimate    | `r round(1-exp(s_HexHH_B.Alpha_rma$b[1]), r.dec)`                                                       | `r round(1-exp(s_HexEM_B.Alpha_rma$b[1]), r.dec)`                                                       | `r round(1-exp(s_HexEX_B.Alpha_rma$b[1]), r.dec)`                                                       | `r round(1-exp(s_HexAG_B.Alpha_rma$b[1]), r.dec)`                                                       | `r round(1-exp(s_HexCO_B.Alpha_rma$b[1]), r.dec)`                                                       |                                                       `r round(1-exp(s_HexOX_B.Alpha_rma$b[1]), r.dec)` |
| Confidence Interval            | `r round(1-exp(s_HexHH_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexHH_B.Alpha_rma$ci.lb), r.dec)` | `r round(1-exp(s_HexEM_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexEM_B.Alpha_rma$ci.lb), r.dec)` | `r round(1-exp(s_HexEX_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexEX_B.Alpha_rma$ci.lb), r.dec)` | `r round(1-exp(s_HexAG_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexAG_B.Alpha_rma$ci.lb), r.dec)` | `r round(1-exp(s_HexCO_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexCO_B.Alpha_rma$ci.lb), r.dec)` | `r round(1-exp(s_HexOX_B.Alpha_rma$ci.ub), r.dec)` : `r round(1-exp(s_HexOX_B.Alpha_rma$ci.lb), r.dec)` |
| Heterogeneity I\^2             | `r round(s_HexHH_B.Alpha_rma$I2, r.dec)`                                                                | `r round(s_HexEM_B.Alpha_rma$I2, r.dec)`                                                                | `r round(s_HexEX_B.Alpha_rma$I2, r.dec)`                                                                | `r round(s_HexAG_B.Alpha_rma$I2, r.dec)`                                                                | `r round(s_HexCO_B.Alpha_rma$I2, r.dec)`                                                                |                                                                `r round(s_HexOX_B.Alpha_rma$I2, r.dec)` |
| Heterogeneity H\^2             | `r round(s_HexHH_B.Alpha_rma$H2, r.dec)`                                                                | `r round(s_HexEM_B.Alpha_rma$H2, r.dec)`                                                                | `r round(s_HexEX_B.Alpha_rma$H2, r.dec)`                                                                | `r round(s_HexAG_B.Alpha_rma$H2, r.dec)`                                                                | `r round(s_HexCO_B.Alpha_rma$H2, r.dec)`                                                                |                                                                `r round(s_HexOX_B.Alpha_rma$H2, r.dec)` |
| Q(`r s_HexHH_B.Alpha_rma$k-1`) | `r round(s_HexHH_B.Alpha_rma$QE, r.dec)`                                                                | `r round(s_HexEM_B.Alpha_rma$QE, r.dec)`                                                                | `r round(s_HexEX_B.Alpha_rma$QE, r.dec)`                                                                | `r round(s_HexAG_B.Alpha_rma$QE, r.dec)`                                                                | `r round(s_HexCO_B.Alpha_rma$QE, r.dec)`                                                                |                                                                `r round(s_HexOX_B.Alpha_rma$QE, r.dec)` |
| P-value QE                     | `r ifelse(s_HexHH_B.Alpha_rma$QEp < .001, "<.001", round(s_HexHH_B.Alpha_rma$QEp, r.dec))`              | `r ifelse(s_HexEM_B.Alpha_rma$QEp < .001, "<.001", round(s_HexEM_B.Alpha_rma$QEp, r.dec))`              | `r ifelse(s_HexEX_B.Alpha_rma$QEp < .001, "<.001", round(s_HexEX_B.Alpha_rma$QEp, r.dec))`              | `r ifelse(s_HexAG_B.Alpha_rma$QEp < .001, "<.001", round(s_HexAG_B.Alpha_rma$QEp, r.dec))`              | `r ifelse(s_HexCO_B.Alpha_rma$QEp < .001, "<.001", round(s_HexCO_B.Alpha_rma$QEp, r.dec))`              |              `r ifelse(s_HexOX_B.Alpha_rma$QEp < .001, "<.001", round(s_HexOX_B.Alpha_rma$QEp, r.dec))` |

#### True Score Variance

| Scale  | HH                                | EM                                | EX                                | AG                                |                                CO |
|------------|------------|------------|------------|------------|-----------:|
| Min    | `r round(s_HexHH_varT[1], r.dec)` | `r round(s_HexEM_varT[1], r.dec)` | `r round(s_HexEX_varT[1], r.dec)` | `r round(s_HexAG_varT[1], r.dec)` | `r round(s_HexCO_varT[1], r.dec)` |
| Q1     | `r round(s_HexHH_varT[2], r.dec)` | `r round(s_HexEM_varT[2], r.dec)` | `r round(s_HexEX_varT[2], r.dec)` | `r round(s_HexAG_varT[2], r.dec)` | `r round(s_HexCO_varT[2], r.dec)` |
| Median | `r round(s_HexHH_varT[3], r.dec)` | `r round(s_HexEM_varT[3], r.dec)` | `r round(s_HexEX_varT[3], r.dec)` | `r round(s_HexAG_varT[3], r.dec)` | `r round(s_HexCO_varT[3], r.dec)` |
| Q3     | `r round(s_HexHH_varT[5], r.dec)` | `r round(s_HexEM_varT[5], r.dec)` | `r round(s_HexEX_varT[5], r.dec)` | `r round(s_HexAG_varT[5], r.dec)` | `r round(s_HexCO_varT[5], r.dec)` |
| Max    | `r round(s_HexHH_varT[6], r.dec)` | `r round(s_HexEM_varT[6], r.dec)` | `r round(s_HexEX_varT[6], r.dec)` | `r round(s_HexAG_varT[6], r.dec)` | `r round(s_HexCO_varT[6], r.dec)` |
| Mean   | `r round(s_HexHH_varT[4], r.dec)` | `r round(s_HexEM_varT[4], r.dec)` | `r round(s_HexEX_varT[4], r.dec)` | `r round(s_HexAG_varT[4], r.dec)` | `r round(s_HexCO_varT[4], r.dec)` |

| Scale                       | HH                                                                                   | EM                                                                                   | EX                                                                                   | AG                                                                                   | CO                                                                                   |                                                                                   OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Meta-analytic mean estimate | `r round(s_HexHH_varT_rma$b[1], r.dec)`                                              | `r round(s_HexEM_varT_rma$b[1], r.dec)`                                              | `r round(s_HexEX_varT_rma$b[1], r.dec)`                                              | `r round(s_HexAG_varT_rma$b[1], r.dec)`                                              | `r round(s_HexCO_varT_rma$b[1], r.dec)`                                              |                                              `r round(s_HexOX_varT_rma$b[1], r.dec)` |
| Confidence Interval         | `r round(s_HexHH_varT_rma$ci.lb, r.dec)` : `r round(s_HexHH_varT_rma$ci.ub, r.dec)`  | `r round(s_HexEM_varT_rma$ci.lb, r.dec)` : `r round(s_HexEM_varT_rma$ci.ub, r.dec)`  | `r round(s_HexEX_varT_rma$ci.lb, r.dec)` : `r round(s_HexEX_varT_rma$ci.ub, r.dec)`  | `r round(s_HexAG_varT_rma$ci.lb, r.dec)` : `r round(s_HexAG_varT_rma$ci.ub, r.dec)`  | `r round(s_HexCO_varT_rma$ci.lb, r.dec)` : `r round(s_HexCO_varT_rma$ci.ub, r.dec)`  |  `r round(s_HexOX_varT_rma$ci.lb, r.dec)` : `r round(s_HexOX_varT_rma$ci.ub, r.dec)` |
| Heterogeneity tau           | `r round(sqrt(s_HexHH_varT_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexEM_varT_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexEX_varT_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexAG_varT_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexCO_varT_rma$tau2), r.dec)`                                        |                                        `r round(sqrt(s_HexOX_varT_rma$tau2), r.dec)` |
| Heteroeneity I\^2           | `r round(s_HexHH_varT_rma$I2, r.dec)`                                                | `r round(s_HexEM_varT_rma$I2, r.dec)`                                                | `r round(s_HexEX_varT_rma$I2, r.dec)`                                                | `r round(s_HexAG_varT_rma$I2, r.dec)`                                                | `r round(s_HexCO_varT_rma$I2, r.dec)`                                                |                                                `r round(s_HexOX_varT_rma$I2, r.dec)` |
| Heterogeneity H\^2          | `r round(s_HexHH_varT_rma$H2, r.dec)`                                                | `r round(s_HexEM_varT_rma$H2, r.dec)`                                                | `r round(s_HexEX_varT_rma$H2, r.dec)`                                                | `r round(s_HexAG_varT_rma$H2, r.dec)`                                                | `r round(s_HexCO_varT_rma$H2, r.dec)`                                                |                                                `r round(s_HexOX_varT_rma$H2, r.dec)` |
| Q(`r s_HexHH_varT_rma$k-1`) | `r round(s_HexHH_varT_rma$QE, r.dec)`                                                | `r round(s_HexEM_varT_rma$QE, r.dec)`                                                | `r round(s_HexEX_varT_rma$QE, r.dec)`                                                | `r round(s_HexAG_varT_rma$QE, r.dec)`                                                | `r round(s_HexCO_varT_rma$QE, r.dec)`                                                |                                                `r round(s_HexOX_varT_rma$QE, r.dec)` |
| P-value QE                  | `r ifelse(s_HexHH_varT_rma$QEp < .001, "<.001", round(s_HexHH_varT_rma$QEp, r.dec))` | `r ifelse(s_HexEM_varT_rma$QEp < .001, "<.001", round(s_HexEM_varT_rma$QEp, r.dec))` | `r ifelse(s_HexEX_varT_rma$QEp < .001, "<.001", round(s_HexEX_varT_rma$QEp, r.dec))` | `r ifelse(s_HexAG_varT_rma$QEp < .001, "<.001", round(s_HexAG_varT_rma$QEp, r.dec))` | `r ifelse(s_HexCO_varT_rma$QEp < .001, "<.001", round(s_HexCO_varT_rma$QEp, r.dec))` | `r ifelse(s_HexOX_varT_rma$QEp < .001, "<.001", round(s_HexOX_varT_rma$QEp, r.dec))` |

#### Error Score Variance

| Scale  | HH                                | EM                                | EX                                | AG                                | CO                                |                                OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Min    | `r round(s_HexHH_varE[1], r.dec)` | `r round(s_HexEM_varE[1], r.dec)` | `r round(s_HexEX_varE[1], r.dec)` | `r round(s_HexAG_varE[1], r.dec)` | `r round(s_HexCO_varE[1], r.dec)` | `r round(s_HexOX_varE[1], r.dec)` |
| Q1     | `r round(s_HexHH_varE[2], r.dec)` | `r round(s_HexEM_varE[2], r.dec)` | `r round(s_HexEX_varE[2], r.dec)` | `r round(s_HexAG_varE[2], r.dec)` | `r round(s_HexCO_varE[2], r.dec)` | `r round(s_HexOX_varE[2], r.dec)` |
| Median | `r round(s_HexHH_varE[3], r.dec)` | `r round(s_HexEM_varE[3], r.dec)` | `r round(s_HexEX_varE[3], r.dec)` | `r round(s_HexAG_varE[3], r.dec)` | `r round(s_HexCO_varE[3], r.dec)` | `r round(s_HexOX_varE[3], r.dec)` |
| Q3     | `r round(s_HexHH_varE[5], r.dec)` | `r round(s_HexEM_varE[5], r.dec)` | `r round(s_HexEX_varE[5], r.dec)` | `r round(s_HexAG_varE[5], r.dec)` | `r round(s_HexCO_varE[5], r.dec)` | `r round(s_HexOX_varE[5], r.dec)` |
| Max    | `r round(s_HexHH_varE[6], r.dec)` | `r round(s_HexEM_varE[6], r.dec)` | `r round(s_HexEX_varE[6], r.dec)` | `r round(s_HexAG_varE[6], r.dec)` | `r round(s_HexCO_varE[6], r.dec)` | `r round(s_HexOX_varE[6], r.dec)` |
| Mean   | `r round(s_HexHH_varE[4], r.dec)` | `r round(s_HexEM_varE[4], r.dec)` | `r round(s_HexEX_varE[4], r.dec)` | `r round(s_HexAG_varE[4], r.dec)` | `r round(s_HexCO_varE[4], r.dec)` | `r round(s_HexOX_varE[4], r.dec)` |

| Scale                       | HH                                                                                   | EM                                                                                   | EX                                                                                   | AG                                                                                   | CO                                                                                   |                                                                                   OX |
|-----------|-----------|-----------|-----------|-----------|-----------|----------:|
| Meta-analytic mean estimate | `r round(s_HexHH_varE_rma$b[1], r.dec)`                                              | `r round(s_HexEM_varE_rma$b[1], r.dec)`                                              | `r round(s_HexEX_varE_rma$b[1], r.dec)`                                              | `r round(s_HexAG_varE_rma$b[1], r.dec)`                                              | `r round(s_HexCO_varE_rma$b[1], r.dec)`                                              |                                              `r round(s_HexOX_varE_rma$b[1], r.dec)` |
| Confidence Interval         | `r round(s_HexHH_varE_rma$ci.lb, r.dec)` : `r round(s_HexHH_varE_rma$ci.ub, r.dec)`  | `r round(s_HexEM_varE_rma$ci.lb, r.dec)` : `r round(s_HexEM_varE_rma$ci.ub, r.dec)`  | `r round(s_HexEX_varE_rma$ci.lb, r.dec)` : `r round(s_HexEX_varE_rma$ci.ub, r.dec)`  | `r round(s_HexAG_varE_rma$ci.lb, r.dec)` : `r round(s_HexAG_varE_rma$ci.ub, r.dec)`  | `r round(s_HexCO_varE_rma$ci.lb, r.dec)` : `r round(s_HexCO_varE_rma$ci.ub, r.dec)`  |  `r round(s_HexOX_varE_rma$ci.lb, r.dec)` : `r round(s_HexOX_varE_rma$ci.ub, r.dec)` |
| Heterogeneity tau           | `r round(sqrt(s_HexHH_varE_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexEM_varE_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexEX_varE_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexAG_varE_rma$tau2), r.dec)`                                        | `r round(sqrt(s_HexCO_varE_rma$tau2), r.dec)`                                        |                                        `r round(sqrt(s_HexOX_varE_rma$tau2), r.dec)` |
| Heteroeneity I\^2           | `r round(s_HexHH_varE_rma$I2, r.dec)`                                                | `r round(s_HexEM_varE_rma$I2, r.dec)`                                                | `r round(s_HexEX_varE_rma$I2, r.dec)`                                                | `r round(s_HexAG_varE_rma$I2, r.dec)`                                                | `r round(s_HexCO_varE_rma$I2, r.dec)`                                                |                                                `r round(s_HexOX_varE_rma$I2, r.dec)` |
| Heterogeneity H\^2          | `r round(s_HexHH_varE_rma$H2, r.dec)`                                                | `r round(s_HexEM_varE_rma$H2, r.dec)`                                                | `r round(s_HexEX_varE_rma$H2, r.dec)`                                                | `r round(s_HexAG_varE_rma$H2, r.dec)`                                                | `r round(s_HexCO_varE_rma$H2, r.dec)`                                                |                                                `r round(s_HexOX_varE_rma$H2, r.dec)` |
| Q(`r s_HexHH_varE_rma$k-1`) | `r round(s_HexHH_varE_rma$QE, r.dec)`                                                | `r round(s_HexEM_varE_rma$QE, r.dec)`                                                | `r round(s_HexEX_varE_rma$QE, r.dec)`                                                | `r round(s_HexAG_varE_rma$QE, r.dec)`                                                | `r round(s_HexCO_varE_rma$QE, r.dec)`                                                |                                                `r round(s_HexOX_varE_rma$QE, r.dec)` |
| P-value QE                  | `r ifelse(s_HexHH_varE_rma$QEp < .001, "<.001", round(s_HexHH_varE_rma$QEp, r.dec))` | `r ifelse(s_HexEM_varE_rma$QEp < .001, "<.001", round(s_HexEM_varE_rma$QEp, r.dec))` | `r ifelse(s_HexEX_varE_rma$QEp < .001, "<.001", round(s_HexEX_varE_rma$QEp, r.dec))` | `r ifelse(s_HexAG_varE_rma$QEp < .001, "<.001", round(s_HexAG_varE_rma$QEp, r.dec))` | `r ifelse(s_HexCO_varE_rma$QEp < .001, "<.001", round(s_HexCO_varE_rma$QEp, r.dec))` | `r ifelse(s_HexOX_varE_rma$QEp < .001, "<.001", round(s_HexOX_varE_rma$QEp, r.dec))` |
